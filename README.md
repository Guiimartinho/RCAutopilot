# RCAutopilot
__Note: This repository is still in progress__
## Overview
This is a small scale demonstration of how a self-driving system could be implemented using a toy radio controlled car. This project has been implemented mainly in Python with a bit of C/C++ needed for the Arduino.
### How it works
__Training__

Before the car can be run in autonomous mode, it needs to be manually trained (my trained model is included). Video is captured by the Raspberry Pi using the Camera Module which is mounted on top of the car. This video is streamed over the wifi network to the PC. A gamepad connected to the PC is used to manually control the car. Each frame of video received is stored on the PC, along with the corresponding user input (steering input and throttle input). The user has to manually drive the car around the track numerous times to collect sufficient training data and cover the different conditions that the car may encounter.
Once the training is complete, a script needs to be run to train the model. Depending on the number of images and the processing power of the PC, the training process can take a few hours. Once the training is complete, a file is produced containing the trained model.

__Driving__

Once the trained model has been obtained, the car can be run in autonomous mode. Once the car is set to autonomous mode and a desired speed is selected, the PC takes the input image streaned from the Raspberry Pi, processes it using a convoluted neural network, and generates an appropriate steering angle. This steering angle is then sent back to the Raspberry Pi over wifi. An Arduino is connected to the Raspberry Pi over USB, and this steering angle is sent to the Arduino. The Arduino is connected to the ESC and provides the appropriate PWM signal to it, ensuring the car turns by the required amount.

## Prerequisites
### Components
These are the components I used to make this project. These aren't set in stone, and can be substituted for other parts that may do a similar or even better job
- Raspberry Pi
- Rapberry Pi Camera Module
- Portable Power Bank (Anker Astro E1 5200 mAh)
- Arduino
- Modified Tamiya Ford Focus RS WRC 02 Chassis
  - TL-01 Chassis
  - TBLE-02S Electronic Speed Control (ESC)
  - 7.2V 3000 mAh NiMH battery
- PC
  - Dedicated graphics card can help speed up training
- TP-Link TL-WR702N Nano Router (optional)
- Xbox One controller (code can be altered to work with other controllers if they can be recognised on Ubuntu)
### Software
The PC should be running Ubuntu (or equivalent) with the following installed:
- Xbox drivers (xboxdrv)
- Pygame
- Numpy
- Tensorflow
- OpenCV (version 2.4.x used here)
- Scipy
- Netifaces

## How to set it up
### Wiring
- Connect the PWM pin (white wire) for the ESC (controlling main forwards/backwards motor) to pin 9 of the Arduino
- Connect the PWM pin for the front steering motor (controlling left/right steering) to pin 8 of the Arduino
- Ensure ESC is common grounded with the Arduino by connecting ground of ESC (black wire) to the GND pin on the Arduino

### ESC Calibration
Chances are, the ESC is calibrated to be used with a RC receiver. The PWM signal from the receiver may be different from the PWM signals generated by the Arduino. To fix this, the ESC needs to be recalibrated with PWM signals from the Arduino. This is a rough guideline on how to achieve this (I don't have an Arduino file for this at the moment, but it should be straightforward to make yourself):

__Create Arduino Sketch__
- Create new Arduino source file (.ino file)
- Import the Servo library
- Create a servo variable for the drive motor (eg `Servo driveMotor;`)
- Attach pin 9 to the drive motor variable in setup (eg. `driveMotor.attach(9);` )
- Write script that will take a number between 0 and 180 from the Serial monitor and write it to the Servo declared above
- Upload this sketch to the Arduino

__Put ESC into Calibration mode__
- First, throttle input to ESC should be set to neutral. Do this by writing `90` to the servo above (using the Serial Monitor)
- To put the ESC into Calibration mode, follow the instructions under "High Point Setup" here: https://www.tamiyausa.com/pdf/manuals/45057ml.pdf
- When the instructions ask you to provide full throttle, write `0` to the servo
- When instructions ask you to provide full brakes, write `180` to the servo

If you completed that without a problem, the ESC should now be calibrated! You can test it by writing different values to the Servo and seeing how the motor reacts. Writing a `90` should neutral the motor so it stops spinning. As you decrease towards `0` the motor should speed up. Between `90` and `180` is braking action, or reverse if it is enabled on the ESC. To engage reverse you may need to input a `neutral-brake-neutral-brake/reverse` sequence eg. writing the following in succession to the servo: `90`, `120`, `90`, `120`. 

### Connecting Components
The Raspberry Pi Camera Module should be connected to the Raspberry Pi using the ribon cable. Mount the Raspberry Pi and the camera on the car. Ensure camera is positioned such that it has a clear view of the track ahead. Connect the Arduino to the Raspberry Pi via a USB cable. Place the power bank on the car and connect it up to power the Raspberry Pi. The powerbank can be disconnected when not in use or when testing on a bench with a powersource already available.

### Setting up the scripts
The Arduino sketch in the `\Arduino\Tamiya_Control\` folder should be uploaded to the Arduino. This can be done by installing the Arduino IDE on the Raspberry Pi directly, or by connecting the Arduino to the PC to upload the sketch, and then connecting it back to the Raspberry Pi.

The script in the "Raspberry Pi" folder should be copied to the Raspberry Pi and the scripts in the PC folder should be copied to the computer running Ubuntu.

At the top of the `Combined_Client.py` script on the Raspberry Pi, ensure the IP address is that of the PC that will be receiving the video stream and computing commands. Also ensure that the port number matches that in the `Gamepad_Driver_Server.py` script on the PC. Also note that the Serial port name given to the Arduino USB port may differ from `ttyACM0`. You can determine the Serial port name by running `dmesg | grep tty` in terminal.

In the `Gamepad_Driver_Server.py` file in the PC folder, near the bottom of the file under the comment `Get PC IP Address` the `wlp3s0` and the `enp4s0` refer to the wireless and wired network interfaces available on my PC. These may be different on yours, and you should change them to match the interfaces on your PC. You can obtain the name by entering `ifconfig` into a terminal window. These lines are used to obtain and display the IP address of the current PC. If you have trouble with these lines, you can remove the `ni.ifaddresses('wlp3s0')` line and set `wifi = 0` and `ethernet = 0` to avoid errors.


## To do:
- Explain how to use the scripts
- Add software version numbers
